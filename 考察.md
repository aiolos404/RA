# 外部コールとして実行するコントラクトの順番
~~コントラクトは、call_stackからpopされた順に実行と呼び出しを行う。~~  
~~AというコントラクトがBというコントラクトをcallする場合、B→Aの順番にpushしておくことで、Aの実行中にcallがあった場合にBを実行することができる。  
しかし、Aの途中でCをcreate →AがBをcall →Aがcをcallするという動作の場合、Bを実行するはずのタイミングでCを実行してしまうことになる。  
これはスタックのLIFOの性質によるためだが、バイトコードレベルではコントラクトの区別が付かないため、特にうまい方法は思いつかない。~~外部コールにstack使うのは中止
(ABIは使いたくない、使っても関数のインターフェースがあっていることを確認しているだけ)
案  
1. call用の全てのcontractに対して、callして実行を行う → 割とありでは 費用対効果は高い
1. call用のコントラクトそれぞれに対しシンボリックなアドレスを割り当て、関数シグネチャに対するシンボリックなアドレスのマッピングを保持、、、、、
1. 関数シグネチャをうまく取り出す方法を見つけて、callしたシグネチャと一致する処理を持っているかを確認する → fallback関数に関数シグネチャはない
1. callとcreateの順番を予め指定する  
→  createしたコントラクトにはアドレスをシンボリック変数として割り当てられるので、呼び出し先を指定可能  
→  複数call,delegatecallがある場合、それらの番地によって呼び出し順を決定  
 
  
結局どこまでできた方がいいのかは新リエントランシーを詳細に読解する必要あり

# callされた外部コントラクト中にreturn命令が複数ある場合
return をシンボリックにn回行う　→　call元の次の命令の実行をn回行わなければならない？  
msg.dataの内容によって分岐しているはずなので初めてreturnされたルートが、呼び出した関数が正しく実行されるルートだとみなしてよいのでは ← だめ　条件分岐して両方からreturnされる場合もある  
複数あるreturnのあるブロックがそれぞれ戻り先となるブロックを複製する必要あり




# Consideration of using symbolic variables as memory indexes
## Consideration of loading and storing using symbolic variables as memory indexes
if
    mem = [3,0,0,,,,]
    mem[Extract(7, 0, x)] = 6
    mem[Extract(15, 8, x)] = 0
    ...
    mem[Extract(255, 248, x)] = 0
→
    Or(
    (Extract(7, 0, x) == 0 => 3==6),
    (Extract(7, 0, x) == 1 => 0==6),,,
    )
→ Extract(7, 0, x) != 0 and Extract(7, 0, x) != 1
→bad

if
    mem = [3,6,8,4,0,0,0,0,,,,]
    mem[Extract(7, 0, x)] = Extract(7, 0, y)
    mem[Extract(15, 8, x)] = Extract(15, 8, y)
    ...
    mem[Extract(255, 248, x)] = Extract(255, 248, y)
→
    Or(
        And(
            (Extract(7, 0, x)==0 => Extract(7, 0, y)==3),
            (Extract(7, 0, x)==1 => Extract(7, 0, y)==6),,,
        ),
        And(
            (Extract(7, 0, x)==1 => Extract(7, 0, y)==6),
        )
    )

→
    Or(
        And(
        (x == 0 => y == Concat(mem[8-1,0-1,-1])),
        (x == 1 => y == Concat(mem[8+1-1,0+1-1,-1])),,,
        (x == i => y == Concat(mem[8+i-1,i-1,-1])
        )
    )
→
    Or(
        And(
        for i in range(memsize()-8):
            (x == i => y == Concat(mem[i+7,i-1,-1]) #from i+7 to i
        )
    )






if
    mem[Extract(7, 0, x)] = Extract(7, 0, y)
    mem[Extract(15, 8, x)] = Extract(15, 8, y)
    ...
    mem[Extract(255, 248, x)] = Extract(255, 248, y)

    mem[Extract(7, 0, v)] = Extract(7, 0, w)
    mem[Extract(15, 8, v)] = Extract(15, 8, w)
    ...
    mem[Extract(255, 248, v)] = Extract(255, 248, w)
→
    Or(
        (x!=v => y!=w),
        (Extract(255, 248, x)==Extract(7, 0, v) => Extract(255, 248, y)==Extract(7, 0, w)),
        And(
            Extract(255, 248, x)==Extract(15, 8, v),
            Extract(247, 240, x)==Extract(7, 0, v)
        ) => And(
            Extract(255, 248, y)==Extract(15, 8, w),
            Extract(247, 240, y)==Extract(7, 0, w)
        ),,,
        x==v => y==w,,,
        Extract(7, 0, x)==Extract(255, 248, v) => Extract(7, 0, y)==Extract(255, 248, w)
            
    )



## Consideration on Memory Size Calculation Using Symbolic Variable as Memory Index
1. the case a symbolic variable is used as index.
If the number of immediate values is 30 and the symbolic variable is x,
it is divided into two cases where x is less than 30 and 30 or more.
But the symbolic variable x contains both cases.
Therefore, the memory size can be x.
1. the case two symbolic variables are used as index.
If the symbolic variables are x and y, 
it is divided into two cases where x is less than y and y or more.
However, if memory size is x, a case where x is less than y is truncated.
So the memory size cannot be decided. However, there may be a proposal to return multiple values as memory size candidates.
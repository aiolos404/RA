# プログラム開始
バイトコードを1つ受け取りbytecode_queueにpush
バイトコードを0以上受け取りcallee_queueにpush

bytecode_queueから一つpopし、実行開始  
途中でCREATEされたバイトコードもbytecode_queueに加えてあとで実行開始


# (シンボリック)実行
## 開始
1. バイトコードを元にexecution_environmentを作成
1. それを元にbasicblockを作成してCFGmanagerのprocessing_blockとして設定
1. VMの各種フィールドにprocessing_blockのmemory等のよく使うデータの参照をコピー(pcは参照コピーにならないが戻すことはない？)
## 実行
1. opecode\[code\[pc:pc+1]]()


# 分岐

## 分岐する場合
1. processing_blockをCFG_nodeに保存(list of block)
1. ジャンプ先pc、続行先pcを用意
1. jump_conditionを登録
1. 新しいblock_numberを2つ生成、edgeを登録
1. processing_blockを複製してprocessing_blockに代入、VM中の各フィールドにも代入
1. pre_pathcondition = path_condition, path_condition = path_condition and jump_condition
1. ジャンプ先pcをセットしてdfs_stackにpush
1. processing_blockを複製してprocessing_blockに代入、VM中の各フィールドにも代入
1. path_condition = pre_pathcondition
1. 続行先pcをセットして実行


### ロールバック時
1. dfs用スタックからprocessing_blockにpop
1. VM中の各フィールドに参照を代入
1. 実行

# createによって新たなコントラクトが生成される場合
## 戻り先の作成
1. processing_blockをCFG_nodeに保存(list of block)
1. 戻り先となるpcをセット
1. processing_blockを複製してcall_stackにpush

## 外部コードの状態作成
1. 初期化コードを元にexec_environmentを作成
1. storage(, returndata)を空にする
1. pc = 0をセット
1. 実行

# createの初期化コード実行時やcallにおいて外部ジャンプする際
## 戻り先の作成
1. 現在の状態をCFGに保存
1. 戻り先となるpcを用意
1. ~~現在の状態をreturn_destとして維持~~ ←　再びコールがあると上書きされる
1. 現在の状態をcall_stackにpush

## 外部コードの状態作成
1. 外部コントラクトの状態をセット
1. storage(, returndata)を空にする
1. 実行

## 外部から戻るとき(create以外)
1. 現在の状態をCFGに保存
1. call_stackの先頭の状態に現在のstack, memory(, returndata)をセット
1. call_stackからpopした状態を復元
1. 実行

## 外部から戻るとき(create時)
1. 現在の状態をCFGに保存
1. 現在のpcが参照している命令の次の番地~末端までを新しいコントラクトしてバイトコード群に追加
1. call_stackの先頭の状態に現在のstack, memory(, returndata)をセット
1. call_stackからpopした状態を復元
1. 実行


# delegatecallにおいて外部ジャンプする際のBasicBlockの扱い
## 戻り先の作成
上に同じ

## 外部コードの状態作成
1. 外部コントラクトの状態をセット
1. 実行

## 外部から戻るとき
1. 現在の状態をCFGに保存
1. call_stackの先頭の状態に現在のstorage, stack, memory(, returndata)をセット
1. call_stackからpopした状態を復元
1. 実行

# 終端到達時(return以外)
1. 現在の状態をCFGに保存
1. dfs用スタックが空でなければロールバック

